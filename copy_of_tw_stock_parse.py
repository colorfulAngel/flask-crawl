# -*- coding: utf-8 -*-
"""Copy of TW_STOCK_PARSE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17fYTfJfPQ0C9dWcVfU7UKGrdbTgLPaej
"""

# !pip install twstock
# !pip install statsmodels
import twstock
import pandas as pd
import numpy as np
import statsmodels.api as sm
from google.colab import files
from datetime import datetime           # 確保引入 datetime
from dateutil.relativedelta import relativedelta
import matplotlib.pyplot as plt

"""# 股票爬蟲與資料準備"""

target_stock = '0050'
stock =  twstock.Stock(target_stock)

# 使用者自訂抓取的歷史資料長度（年），例如 3.5 年
fetch_years = 3.5  # 可以修改或透過 input() 讓使用者輸入

# 計算起始日期：從今天往回 fetch_years 年
today = datetime.today()
# 將小數部分轉換成月數
years_int = int(fetch_years)
months_decimal = int(round((fetch_years - years_int) * 12, 0))
start_date = today - relativedelta(years=years_int, months=months_decimal)
start_year = start_date.year
start_month = start_date.month

print(f"抓取資料起始日期：{start_year}-{start_month}")

# 取得資料：從計算出的起始年月開始抓取
target_price = stock.fetch_from(start_year, start_month)

#target_price = stock.fetch_from(2021, 10)
print(target_price)

name_attribute = ['Date', 'Capacity', 'Turnover', 'Open', 'High', 'Low', 'Close', 'Change', 'Transcation']
df = pd.DataFrame( columns= name_attribute, data = target_price)
print(df)

filename = '{target_stock}.csv'
df.to_csv(filename)
#files.download(filename)

"""# 週線重採樣 (原有功能)"""

def resample_to_weekly(df):


    weekly_df = df.resample('W').agg({

        'Capacity': 'sum',

        'Turnover': 'sum',

        'Open': 'first',


        'High': 'max',


        'Low': 'min',


        'Close': 'last',


        'Change': 'sum',

        'Transcation': 'sum',

        'compdate': 'max',

    })


    return weekly_df

df2 = pd.DataFrame( columns= name_attribute, data = target_price)
df2['compdate']=df2['Date']
df2.set_index('Date', inplace=True)
#df2['date'] = df.index
weekly_df = resample_to_weekly(df2)
print(weekly_df)

"""股價五線譜計算：根據整個母體資料計算趨勢線與標準差"""

def calculate_five_line_spectrum(df):
    """
    輸入 DataFrame 必須包含：
    - 'Close'：收盤價
    - DataFrame 的索引為日期（datetime）
    此函數將計算：
    - 趨勢線：根據所有交易日以線性回歸計算 (y = a + b*x)
    - 母體標準差：整個資料區間，差異數 (Close - TrendLine) 的標準差
    - 95% 樂觀線、75% 樂觀線、75% 悲觀線、95% 悲觀線
    """
    # 複製 DataFrame 避免修改原始數據
    df = df.copy()

    # 產生交易日序號，從 1 起算（假設資料已按日期排序）
    df["TradingDay"] = np.arange(1, len(df)+1)

    # 線性回歸計算趨勢線：y = a + b*x，使用收盤價作為 y，TradingDay 作為 x
    X = sm.add_constant(df["TradingDay"])  # 增加截距項
    model = sm.OLS(df["Close"], X).fit()
    df["TrendLine"] = model.predict(X)

    # 計算差異數 = 收盤價 - 趨勢線
    df["Difference"] = df["Close"] - df["TrendLine"]

    # 計算整個資料區間的母體標準差 (使用 ddof=0)
    std_overall = np.std(df["Difference"], ddof=0)

    # 計算五線譜：
    df["95% Optimistic"] = df["TrendLine"] + 2 * std_overall
    df["75% Optimistic"] = df["TrendLine"] + 1 * std_overall
    df["75% Pessimistic"] = df["TrendLine"] - 1 * std_overall
    df["95% Pessimistic"] = df["TrendLine"] - 2 * std_overall

    # 回傳包含五線譜的 DataFrame
    return df, std_overall, model.params

# 將股價五線譜計算整合進主程式：以原始爬取的資料 df2（以 Date 為索引）
five_line_df, std_val, params = calculate_five_line_spectrum(df2)
print("股價五線譜計算結果:")
print(five_line_df[["Close", "TrendLine", "Difference", "95% Optimistic", "75% Optimistic", "75% Pessimistic", "95% Pessimistic"]])

# 儲存股價五線譜計算結果至 CSV，供後續分析使用
filename_five = f'{target_stock}_five_line_spectrum.csv'
five_line_df.to_csv(filename_five)
#files.download(filename_five)

# 設定圖表大小
plt.figure(figsize=(12, 6))
# 繪製股價五線譜
plt.plot(five_line_df.index, five_line_df["Close"], color="blue", label="Close")
plt.plot(five_line_df.index, five_line_df["TrendLine"], color="black", linestyle="dashed", label="TL")
plt.plot(five_line_df.index, five_line_df["95% Optimistic"], color="red", linestyle="solid", label="+2 STDEV")
plt.plot(five_line_df.index, five_line_df["75% Optimistic"], color="orange", linestyle="solid", label="+1 STDEV")
plt.plot(five_line_df.index, five_line_df["75% Pessimistic"], color="green", linestyle="solid", label="-1 STDEV")
plt.plot(five_line_df.index, five_line_df["95% Pessimistic"], color="darkgreen", linestyle="solid", label="-2 STDEV")

# 標記最新數據點
latest = five_line_df.iloc[-1]
plt.scatter(latest.name, latest["Close"], color="blue", s=100, label=f"Price: {latest['Close']}")
plt.scatter(latest.name, latest["TrendLine"], color="black", s=100, label=f"TL: {latest['TrendLine']}")
plt.scatter(latest.name, latest["95% Optimistic"], color="red", s=100, label=f"+2 STDEV: {latest['95% Optimistic']}")
plt.scatter(latest.name, latest["75% Optimistic"], color="orange", s=100, label=f"+1 STDEV: {latest['75% Optimistic']}")
plt.scatter(latest.name, latest["75% Pessimistic"], color="green", s=100, label=f"-1 STDEV: {latest['75% Pessimistic']}")
plt.scatter(latest.name, latest["95% Pessimistic"], color="darkgreen", s=100, label=f"-2 STDEV: {latest['95% Pessimistic']}")

# 設定圖表標題與軸標籤
plt.title(f"{target_stock} 樂活五線譜")
plt.xlabel("日期")
plt.ylabel("股價")

# 加入圖例
plt.legend(loc="upper left")

# 顯示圖表
plt.show()

"""畫圖

# 大趨勢運算：計算上界與下界

# BigTrend
"""

def calculate_trend_bounds(weekly_df):
    # 過濾掉 Close 為 0 的資料
    df_trend = weekly_df[weekly_df['Capacity'] != 0].copy()

    # 計算 20 週移動平均的 Close (MA20)
    df_trend['MA20'] = df_trend['Close'].rolling(window=20, min_periods=1).mean()

    # 計算相關欄位
    df_trend['HL'] = df_trend['High'] - df_trend['Low']
    df_trend['H_plus_L_div2'] = (df_trend['High'] + df_trend['Low']) / 2
    df_trend['I_over_J'] = df_trend['HL'] / df_trend['H_plus_L_div2']
    df_trend['one_plus_2K'] = 1 + 2 * df_trend['I_over_J']
    df_trend['HX_L'] = df_trend['High'] * df_trend['one_plus_2K']
    df_trend['one_minus_2K'] = 2 - df_trend['one_plus_2K']  # 此處即 1-2K 的計算
    df_trend['L_N'] = df_trend['Low'] * df_trend['one_minus_2K']

    # 計算20週移動平均上界與下界 (若不足20筆則以 min_periods=1 計算)
    df_trend['upperbound'] = df_trend['HX_L'].rolling(window=20, min_periods=1).mean()
    df_trend['lowerbound'] = df_trend['L_N'].rolling(window=20, min_periods=1).mean()

    # 根據當週 Close 與上下界判斷突破信號
    def get_signal(row):
        if pd.notna(row['upperbound']) and row['Close'] > row['upperbound']:
            return "Breakout Up"
        elif pd.notna(row['lowerbound']) and row['Close'] < row['lowerbound']:
            return "Breakout Down"
        else:
            return "No Breakout"

    df_trend['Signal'] = df_trend.apply(get_signal, axis=1)
    return df_trend

trend_df = calculate_trend_bounds(weekly_df)
print("大趨勢運算結果:")
print(trend_df[['Close', 'MA20', 'upperbound', 'lowerbound', 'Signal']])

filename_trend = f'{target_stock}_trend_bounds.csv'
trend_df.to_csv(filename_trend)
#files.download(filename_trend)

"""# 繪圖前把 Close=0 的那週資料"整筆"移除"""

plot_df = trend_df.copy()
# 刪除 Close=0 的該筆資料（包含該日期）
plot_df = plot_df[plot_df['Capacity'] != 0]

"""# 繪製大趨勢圖表 (週線收盤、MA20、Upper、Lower)"""

plt.figure(figsize=(12, 6))

# 週線收盤價
plt.plot(plot_df.index, plot_df['Close'], color="blue", label="Weekly Close")

# 20MA
plt.plot(plot_df.index, plot_df['MA20'], color="purple", linestyle="dashed", label="20MA")

# 上下界
plt.plot(plot_df.index, plot_df['upperbound'], color="red", label="Upper Bound")
plt.plot(plot_df.index, plot_df['lowerbound'], color="green", label="Lower Bound")

# 取最新一筆（可能為最近一週）
if len(plot_df) > 0:
    latest = plot_df.iloc[-1]
    plt.scatter(latest.name, latest["Close"], color="blue", s=70,
                label=f"Price: {latest['Close']}")
    plt.scatter(latest.name, latest["MA20"], color="purple", s=70,
                label=f"MA20: {latest['MA20']}")
    plt.scatter(latest.name, latest["upperbound"], color="red", s=70,
                label=f"Upper Bound: {latest['upperbound']}")
    plt.scatter(latest.name, latest["lowerbound"], color="green", s=70,
                label=f"Lower Bound: {latest['lowerbound']}")

plt.title(f"{target_stock} (20MA, Upper/Lower Bound)")
plt.xlabel("日期")
plt.ylabel("股價")
plt.legend(loc="upper left")
plt.show()

"""#AE2"""

"""# AE2 指標計算與畫圖"""

# 先移除 weekly_df 中 Close 為 0 的資料，避免計算及畫圖受到影響
ae2_df = weekly_df[weekly_df['Capacity'] != 0].copy()
ae2_df = ae2_df.sort_index()

# 初始化新欄位
ae2_df['Force'] = 0.0
ae2_df['EMA26'] = 0.0
ae2_df['EMA13'] = 0.0
ae2_df['EMA13_26'] = 0.0
ae2_df['MAAE2'] = 0.0
ae2_df['AE2'] = 0.0

# 依週遞迴計算 (從第二週開始)
for i, current_date in enumerate(ae2_df.index):
    if i == 0:
        ae2_df.at[current_date, 'Force'] = 0.0
        ae2_df.at[current_date, 'EMA26'] = 0.0
        ae2_df.at[current_date, 'EMA13'] = 0.0
        ae2_df.at[current_date, 'EMA13_26'] = 0.0
        ae2_df.at[current_date, 'MAAE2'] = 0.0
        ae2_df.at[current_date, 'AE2'] = 0.0
    else:
        prev_date = ae2_df.index[i-1]
        # 力度：Force = (本週Close - 上週Close) * 本週Capacity
        force = (ae2_df.at[current_date, 'Close'] - ae2_df.at[prev_date, 'Close']) * ae2_df.at[current_date, 'Capacity']
        ae2_df.at[current_date, 'Force'] = force

        # EMA26 = (Force - 上週EMA26) * (2/27) + 上週EMA26
        prev_EMA26 = ae2_df.at[prev_date, 'EMA26']
        ema26 = (force - prev_EMA26) * (2/27) + prev_EMA26
        ae2_df.at[current_date, 'EMA26'] = ema26

        # EMA13 = (Force - 上週EMA13) * (2/14) + 上週EMA13
        prev_EMA13 = ae2_df.at[prev_date, 'EMA13']
        ema13 = (force - prev_EMA13) * (2/14) + prev_EMA13
        ae2_df.at[current_date, 'EMA13'] = ema13

        # EMA13_26 = EMA13 - EMA26
        ema13_26 = ema13 - ema26
        ae2_df.at[current_date, 'EMA13_26'] = ema13_26

        # MAAE2 = (EMA13_26 - 上週MAAE2) * (2/10) + 上週MAAE2
        prev_MAAE2 = ae2_df.at[prev_date, 'MAAE2']
        maae2 = (ema13_26 - prev_MAAE2) * (2/10) + prev_MAAE2
        ae2_df.at[current_date, 'MAAE2'] = maae2

        # AE2 = EMA13_26 - MAAE2
        ae2 = ema13_26 - maae2
        ae2_df.at[current_date, 'AE2'] = ae2
# 計算交易訊號：若上一期 AE2 小於 0 而本期大於 0，標記 "Buy"，若上一期大於 0而本期小於 0，標記 "Sell"
ae2_df['Signal'] = np.where((ae2_df['AE2'].shift(1) < 0) & (ae2_df['AE2'] > 0), "Buy",
                      np.where((ae2_df['AE2'].shift(1) > 0) & (ae2_df['AE2'] < 0), "Sell", ""))

#print("AE2 指標計算結果:")
#print(ae2_df[['Close', 'Force', 'EMA26', 'EMA13', 'EMA13_26', 'MAAE2', 'AE2']])

# 儲存 AE2 計算結果至 CSV
filename_ae2 = f'{target_stock}_AE2.csv'
ae2_df.to_csv(filename_ae2)
files.download(filename_ae2)

"""# AE2 指標圖表 (雙 y 軸)
我們將 AE2 指標繪製在左側 y 軸，
並將 Weekly Close Price 繪製在右側 y 軸，這樣可以清楚呈現兩者的變化。
"""

plt.figure(figsize=(12, 6))
# 建立主圖與副圖
ax1 = plt.gca()  # 主軸，負責繪製 AE2
ax2 = ax1.twinx()  # 副軸，負責繪製 Weekly Close Price

# 繪製 AE2 指標曲線 (主軸)
ax1.plot(ae2_df.index, ae2_df['AE2'], color="magenta", linewidth=2, label="AE2")
# 標出 AE2 的 0 線
ax1.axhline(y=0, color="gray", linestyle="--", linewidth=1)

# 繪製 Weekly Close Price (副軸)
ax2.plot(ae2_df.index, ae2_df['Close'], color="blue", linewidth=2, label="Weekly Close Price")


# 標註交易訊號
buy_signals = ae2_df[ae2_df['Signal'] == "Buy"]
sell_signals = ae2_df[ae2_df['Signal'] == "Sell"]

ax1.scatter(buy_signals.index, buy_signals['AE2'], marker="^", color="green", s=100, label="Buy Signal")
ax1.scatter(sell_signals.index, sell_signals['AE2'], marker="v", color="red", s=100, label="Sell Signal")

# 設定各軸標籤與顏色
ax1.set_xlabel("日期")
ax1.set_ylabel("AE2", color="magenta")
ax2.set_ylabel("Weekly Close Price", color="blue")

# 整合圖例：由於使用了雙軸，因此需分別取得兩個軸的圖例資訊
lines1, labels1 = ax1.get_legend_handles_labels()
lines2, labels2 = ax2.get_legend_handles_labels()
ax1.legend(lines1 + lines2, labels1 + labels2, loc="upper left")

plt.title(f"{target_stock} AE2 指標與 Weekly Close Price")
plt.show()

"""# AE2GPT"""

"""# AE2_GPT 改良版 (以 DEMA 替代 EMA 計算，並計算交易訊號)"""

# 先移除 weekly_df 中 Close 為 0 的資料，避免計算時出現問題
ae2_gpt_df = weekly_df[weekly_df['Capacity'] != 0].copy()
ae2_gpt_df = ae2_gpt_df.sort_index()

# 新增所需欄位，初始值皆設為 0
ae2_gpt_df['Force'] = 0.0
ae2_gpt_df['EMA26'] = 0.0
ae2_gpt_df['EMA26_2'] = 0.0  # 用於計算 DEMA26 的 EMA(EMA)
ae2_gpt_df['DEMA26'] = 0.0

ae2_gpt_df['EMA13'] = 0.0
ae2_gpt_df['EMA13_2'] = 0.0  # 用於計算 DEMA13 的 EMA(EMA)
ae2_gpt_df['DEMA13'] = 0.0

ae2_gpt_df['DEMA13_26'] = 0.0  # DEMA13 - DEMA26

ae2_gpt_df['MAAE2'] = 0.0
ae2_gpt_df['AE2_GPT'] = 0.0

# 定義參數 (期數)
N26 = 26
N13 = 13
N_MAAE2 = 10

k26 = 2 / (N26 + 1)   # 2/27
k13 = 2 / (N13 + 1)   # 2/14
k_MAAE2 = 2 / (N_MAAE2 + 1)  # 2/11

# 依週迴圈計算各指標
for i, current_date in enumerate(ae2_gpt_df.index):
    if i == 0:
        # 第一筆初始值
        ae2_gpt_df.at[current_date, 'Force'] = 0.0
        ae2_gpt_df.at[current_date, 'EMA26'] = 0.0
        ae2_gpt_df.at[current_date, 'EMA26_2'] = 0.0
        ae2_gpt_df.at[current_date, 'DEMA26'] = 0.0

        ae2_gpt_df.at[current_date, 'EMA13'] = 0.0
        ae2_gpt_df.at[current_date, 'EMA13_2'] = 0.0
        ae2_gpt_df.at[current_date, 'DEMA13'] = 0.0

        ae2_gpt_df.at[current_date, 'DEMA13_26'] = 0.0

        ae2_gpt_df.at[current_date, 'MAAE2'] = 0.0
        ae2_gpt_df.at[current_date, 'AE2_GPT'] = 0.0
    else:
        prev_date = ae2_gpt_df.index[i-1]
        # 力度 Force = (本週Close - 上週Close) * 本週 Capacity
        force = (ae2_gpt_df.at[current_date, 'Close'] - ae2_gpt_df.at[prev_date, 'Close']) * ae2_gpt_df.at[current_date, 'Capacity']
        ae2_gpt_df.at[current_date, 'Force'] = force

        # ----- DEMA26 計算 (使用 k26)
        prev_EMA26 = ae2_gpt_df.at[prev_date, 'EMA26']
        EMA26 = (force - prev_EMA26) * k26 + prev_EMA26
        ae2_gpt_df.at[current_date, 'EMA26'] = EMA26

        prev_EMA26_2 = ae2_gpt_df.at[prev_date, 'EMA26_2']
        EMA26_2 = (EMA26 - prev_EMA26_2) * k26 + prev_EMA26_2
        ae2_gpt_df.at[current_date, 'EMA26_2'] = EMA26_2

        DEMA26 = 2 * EMA26 - EMA26_2
        ae2_gpt_df.at[current_date, 'DEMA26'] = DEMA26

        # ----- DEMA13 計算 (使用 k13)
        prev_EMA13 = ae2_gpt_df.at[prev_date, 'EMA13']
        EMA13 = (force - prev_EMA13) * k13 + prev_EMA13
        ae2_gpt_df.at[current_date, 'EMA13'] = EMA13

        prev_EMA13_2 = ae2_gpt_df.at[prev_date, 'EMA13_2']
        EMA13_2 = (EMA13 - prev_EMA13_2) * k13 + prev_EMA13_2
        ae2_gpt_df.at[current_date, 'EMA13_2'] = EMA13_2

        DEMA13 = 2 * EMA13 - EMA13_2
        ae2_gpt_df.at[current_date, 'DEMA13'] = DEMA13

        # ----- DEMA13_26: 差值
        DEMA13_26 = DEMA13 - DEMA26
        ae2_gpt_df.at[current_date, 'DEMA13_26'] = DEMA13_26

        # ----- MAAE2 計算 (使用 k_MAAE2)
        prev_MAAE2 = ae2_gpt_df.at[prev_date, 'MAAE2']
        MAAE2 = (DEMA13_26 - prev_MAAE2) * k_MAAE2 + prev_MAAE2
        ae2_gpt_df.at[current_date, 'MAAE2'] = MAAE2

        # ----- AE2_GPT 指標
        AE2_GPT = DEMA13_26 - MAAE2
        ae2_gpt_df.at[current_date, 'AE2_GPT'] = AE2_GPT

# 計算交易訊號：前一期 AE2_GPT < 0 且本期 > 0 為 "Buy"；前一期 > 0 且本期 < 0 為 "Sell"
ae2_gpt_df['Signal_GPT'] = np.where(
    (ae2_gpt_df['AE2_GPT'].shift(1) < 0) & (ae2_gpt_df['AE2_GPT'] > 0),
    "Buy",
    np.where((ae2_gpt_df['AE2_GPT'].shift(1) > 0) & (ae2_gpt_df['AE2_GPT'] < 0), "Sell", "")
)

print("AE2_GPT 指標及交易訊號計算結果:")
print(ae2_gpt_df[['Close', 'Force', 'DEMA26', 'DEMA13', 'DEMA13_26', 'MAAE2', 'AE2_GPT', 'Signal_GPT']])

# 儲存 AE2_GPT 計算結果至 CSV
filename_ae2_gpt = f'{target_stock}_AE2_GPT.csv'
ae2_gpt_df.to_csv(filename_ae2_gpt)
#files.download(filename_ae2_gpt)

"""# AE2_GPT 指標圖表 (雙 y 軸與交易訊號標註)
- 主軸：繪製 AE2_GPT 並標示買賣訊號 (Buy 與 Sell)
- 副軸：繪製 Weekly Close Price (獨立軸，因數值較小)
"""

plt.figure(figsize=(12, 6))
ax1 = plt.gca()       # 主軸，用於 AE2_GPT
ax2 = ax1.twinx()     # 副軸，用於 Weekly Close Price

# 繪製 AE2_GPT 曲線 (主軸)
ax1.plot(ae2_gpt_df.index, ae2_gpt_df['AE2_GPT'], color="magenta", linewidth=2, label="AE2_GPT")
# 畫出 0 線
ax1.axhline(y=0, color="gray", linestyle="--", linewidth=1)

# 繪製 Weekly Close Price (副軸)
ax2.plot(ae2_gpt_df.index, ae2_gpt_df['Close'], color="blue", linewidth=2, label="Weekly Close Price")

# 標註交易訊號
buy_signals_gpt = ae2_gpt_df[ae2_gpt_df['Signal_GPT'] == "Buy"]
sell_signals_gpt = ae2_gpt_df[ae2_gpt_df['Signal_GPT'] == "Sell"]

ax1.scatter(buy_signals_gpt.index, buy_signals_gpt['AE2_GPT'], marker="^", color="green", s=100, label="Buy Signal")
ax1.scatter(sell_signals_gpt.index, sell_signals_gpt['AE2_GPT'], marker="v", color="red", s=100, label="Sell Signal")

# 標記最新數據點 (可選)
latest_gpt = ae2_gpt_df.iloc[-1]
ax1.scatter(latest_gpt.name, latest_gpt['AE2_GPT'], color="black", s=100, label=f"Latest AE2_GPT: {latest_gpt['AE2_GPT']:.2f}")
ax2.scatter(latest_gpt.name, latest_gpt['Close'], color="blue", s=100, label=f"Latest Close: {latest_gpt['Close']}")

# 設定軸標籤與顏色
ax1.set_xlabel("日期")
ax1.set_ylabel("AE2_GPT", color="magenta")
ax2.set_ylabel("Weekly Close Price", color="blue")

# 整合圖例 (兩軸圖)
lines1, labels1 = ax1.get_legend_handles_labels()
lines2, labels2 = ax2.get_legend_handles_labels()
ax1.legend(lines1 + lines2, labels1 + labels2, loc="upper left")

plt.title(f"{target_stock} AE2_GPT 指標與 Weekly Close Price (雙 y 軸)")
plt.show()

"""# AE2_GPT 指標圖表 (雙 y 軸與交易訊號標註)
- 主軸：繪製 AE2_GPT 並標示買賣訊號 (Buy 與 Sell)
- 副軸：繪製 Weekly Close Price (獨立軸，因數值較小)
"""

plt.figure(figsize=(12, 6))
ax1 = plt.gca()       # 主軸，用於 AE2_GPT
ax2 = ax1.twinx()     # 副軸，用於 Weekly Close Price

# 繪製 AE2_GPT 曲線 (主軸)
ax1.plot(ae2_gpt_df.index, ae2_gpt_df['AE2_GPT'], color="magenta", linewidth=2, label="AE2_GPT")
# 畫出 0 線
ax1.axhline(y=0, color="gray", linestyle="--", linewidth=1)

# 繪製 Weekly Close Price (副軸)
ax2.plot(ae2_gpt_df.index, ae2_gpt_df['Close'], color="blue", linewidth=2, label="Weekly Close Price")

# 標註交易訊號
buy_signals_gpt = ae2_gpt_df[ae2_gpt_df['Signal_GPT'] == "Buy"]
sell_signals_gpt = ae2_gpt_df[ae2_gpt_df['Signal_GPT'] == "Sell"]

ax1.scatter(buy_signals_gpt.index, buy_signals_gpt['AE2_GPT'], marker="^", color="green", s=100, label="Buy Signal")
ax1.scatter(sell_signals_gpt.index, sell_signals_gpt['AE2_GPT'], marker="v", color="red", s=100, label="Sell Signal")

# 標記最新數據點 (可選)
latest_gpt = ae2_gpt_df.iloc[-1]
ax1.scatter(latest_gpt.name, latest_gpt['AE2_GPT'], color="black", s=100, label=f"Latest AE2_GPT: {latest_gpt['AE2_GPT']:.2f}")
ax2.scatter(latest_gpt.name, latest_gpt['Close'], color="blue", s=100, label=f"Latest Close: {latest_gpt['Close']}")

# 設定軸標籤與顏色
ax1.set_xlabel("日期")
ax1.set_ylabel("AE2_GPT", color="magenta")
ax2.set_ylabel("Weekly Close Price", color="blue")

# 整合圖例 (兩軸圖)
lines1, labels1 = ax1.get_legend_handles_labels()
lines2, labels2 = ax2.get_legend_handles_labels()
ax1.legend(lines1 + lines2, labels1 + labels2, loc="upper left")

plt.title(f"{target_stock} AE2_GPT 指標與 Weekly Close Price (雙 y 軸)")
plt.show()

"""# BackTest AE2"""

def backtest_strategy(df, signal_col, price_col):
    """
    回測策略：
      當未持倉且出現 Buy 信號時，以該週 Close 價買進1單位股票；
      當持倉中且出現 Sell 信號時，以該週 Close 價賣出持倉（平倉）。
      若最後仍持倉，則以最後一筆的 Close 價平倉。
    回傳：
      trades_df: 每筆交易的進出日期、進出價及獲利
      win_rate: 勝率
      max_drawdown: 最大回撤（負值）
      total_profit: 總獲利（累積權益變化）
      equity_df: 權益曲線（以日期為index）
    """
    trades = []
    equity_curve = []
    position = 0
    entry_price = None
    entry_date = None
    equity = 0  # 初始權益

    # 遍歷所有日期
    for date, row in df.iterrows():
        signal = row[signal_col]
        price = row[price_col]
        # 若無持倉且出現 Buy 信號，則買進
        if position == 0 and signal == "Buy":
            entry_price = price
            entry_date = date
            position = 1
        # 若已持倉且出現 Sell 信號，則平倉
        elif position == 1 and signal == "Sell":
            profit = price - entry_price
            equity += profit
            trades.append({
                'Entry_Date': entry_date,
                'Entry_Price': entry_price,
                'Exit_Date': date,
                'Exit_Price': price,
                'Profit': profit
            })
            position = 0
            entry_price = None
            entry_date = None
        # 計算當天的權益：
        if position == 1:
            current_equity = equity + (price - entry_price)
        else:
            current_equity = equity
        equity_curve.append((date, current_equity))

    # 如果最後還持有部位，則以最後一天平倉
    if position == 1:
        last_date = df.index[-1]
        last_price = df.iloc[-1][price_col]
        profit = last_price - entry_price
        equity += profit
        trades.append({
            'Entry_Date': entry_date,
            'Entry_Price': entry_price,
            'Exit_Date': last_date,
            'Exit_Price': last_price,
            'Profit': profit
        })
        # 更新最後的權益值
        equity_curve[-1] = (last_date, equity)

    # 轉換權益曲線為 DataFrame
    equity_df = pd.DataFrame(equity_curve, columns=['Date', 'Equity']).set_index('Date')

    # 計算勝率
    trades_df = pd.DataFrame(trades)
    if len(trades_df) > 0:
        win_rate = (trades_df['Profit'] > 0).sum() / len(trades_df)
    else:
        win_rate = np.nan

    # 計算最大回撤：從權益曲線中，計算每個點相對於前期最高值的跌幅
    running_max = equity_df['Equity'].cummax()
    drawdown = equity_df['Equity'] - running_max
    max_drawdown = drawdown.min()

    total_profit = equity  # 最終權益變化為總獲利

    return trades_df, win_rate, max_drawdown, total_profit, equity_df

# 回測原始 AE2 策略（使用 ae2_df，信號欄位 "Signal"）
trades_ae2, win_rate_ae2, mdd_ae2, total_profit_ae2, equity_df_ae2 = backtest_strategy(ae2_df, 'Signal', 'Close')

print("原始 AE2 策略回測結果:")
print(trades_ae2)
print(f"勝率: {win_rate_ae2:.2%}")
print(f"最大回撤: {mdd_ae2:.2f}")
print(f"總獲利: {total_profit_ae2:.2f}")

# 假設 AE2_GPT 的計算結果存放在 ae2_gpt_df，信號欄位為 "Signal_GPT"
# 請確認 ae2_gpt_df 已正確計算且Close價格非0
# 例如：
# trades_ae2_gpt, win_rate_ae2_gpt, mdd_ae2_gpt, total_profit_ae2_gpt, equity_df_ae2_gpt = backtest_strategy(ae2_gpt_df, 'Signal_GPT', 'Close')
# print("AE2_GPT 策略回測結果:")
# print(trades_ae2_gpt)
# print(f"勝率: {win_rate_ae2_gpt:.2%}")
# print(f"最大回撤: {mdd_ae2_gpt:.2f}")
# print(f"總獲利: {total_profit_ae2_gpt:.2f}")

# === 繪圖：將原始 AE2 與權益曲線畫在同一圖中（使用雙 y 軸）
plt.figure(figsize=(14, 7))
ax1 = plt.gca()       # 左軸：AE2 原始指標 (AE2)
ax2 = ax1.twinx()     # 右軸：Weekly Close Price

# 繪製 AE2_orig 指標曲線（假設 ae2_df 已有 'AE2_orig' 欄位）
ax1.plot(ae2_df.index, ae2_df['AE2'], color="magenta", linewidth=2, label="AE2")
ax1.axhline(y=0, color="gray", linestyle="--", linewidth=1)

# 標註交易訊號 (買進與賣出)
buy_signals = ae2_df[ae2_df['Signal'] == "Buy"]
sell_signals = ae2_df[ae2_df['Signal'] == "Sell"]
ax1.scatter(buy_signals.index, buy_signals['AE2'], marker="^", color="green", s=100, label="Buy Signal")
ax1.scatter(sell_signals.index, sell_signals['AE2'], marker="v", color="red", s=100, label="Sell Signal")

# 副軸：繪製 Weekly Close Price，並單獨使用右軸刻度
ax2.plot(ae2_df.index, ae2_df['Close'], color="blue", linewidth=2, label="Weekly Close Price")

# 設定軸標籤與顏色
ax1.set_xlabel("日期")
ax1.set_ylabel("AE2", color="magenta")
ax2.set_ylabel("Weekly Close Price", color="blue")

# 整合圖例：兩軸圖例合併
lines1, labels1 = ax1.get_legend_handles_labels()
lines2, labels2 = ax2.get_legend_handles_labels()
ax1.legend(lines1 + lines2, labels1 + labels2, loc="upper left")

plt.title(f"{target_stock} 原始 AE2 策略與 Weekly Close Price")
plt.show()

# === 繪製權益曲線圖 (回測結果)
plt.figure(figsize=(12,6))
plt.plot(equity_df_ae2.index, equity_df_ae2['Equity'], color="darkorange", linewidth=2, label="Equity Curve (AE2)")
plt.xlabel("日期")
plt.ylabel("累積獲利")
plt.title(f"{target_stock} AE2 策略權益曲線")
plt.legend(loc="upper left")
plt.show()

# 回測原始 AE2_GPT 策略（使用 ae2_df，信號欄位 "Signal"）
trades_ae2_gpt, win_rate_ae2_gpt, mdd_ae2_gpt, total_profit_ae2_gpt, equity_df_ae2_gpt = backtest_strategy(ae2_gpt_df, 'Signal_GPT', 'Close')

print("原始 AE2 策略回測結果:")
print(trades_ae2_gpt)
print(f"勝率: {win_rate_ae2_gpt:.2%}")
print(f"最大回撤: {mdd_ae2_gpt:.2f}")
print(f"總獲利: {total_profit_ae2_gpt:.2f}")